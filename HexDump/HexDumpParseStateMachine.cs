// Copyright (c) Drew Noakes. All Rights Reserved. Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HexDump
{
    public static partial class HexDump
    {

        private static readonly byte[] _smlookup1 =
        {
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        };

        private static readonly byte[] _smlookup2 =
        {
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        };


        private static readonly byte[] _smsep =
        {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        };

        public class Config
        {
            public int Offset;
            public int Hex;
            public int Ascii;
            public int Eol;
        }

        /// <summary>
        /// Parse HexDump into a byte array
        /// </summary>
        /// <param name="dump"></param>
        /// <returns></returns>
        public static byte[] ParseStasteMachine(string dump)
        {

            //0000    01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    ................
            //0000    01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    ................
            //0000    9A 20 31 32 20 9A 9A 9A  9A 9A 9A 9A 9A 9A 9A 9A    . 12 ...........

            var result = new List<byte>();
            var span = dump.AsSpan();
            var len = span.Length;
            var config = Analyse(span);
            
            for (int i = 0; i < len;)
            {

                i += config.Offset;
                for (int j = 0; j < config.Hex; j += 3)
                {
                    var off = i + j;
                    if (off > len)
                    {
                        break;
                    }

                    if (_smlookup1[span[off + 0]] != 0xff
                        && _smlookup2[span[off + 1]] != 0xff)
                    {
                        byte dec = (byte) (
                            _smlookup1[span[off + 0]]
                            + _smlookup2[span[off + 1]]
                        );

                        result.Add(dec);
                    }
                    
                    if (off + 3 < len
                        && span[off + 3] == ' ')
                    {
                        j++;
                    }
                }

                i += config.Hex;
                i += config.Ascii;
                i += config.Eol;

            }

            return result.ToArray();
        }

        public static Config Analyse(in ReadOnlySpan<char> span)
        {
            var p = new Process();
            var len = span.Length;
            var pm = new Config
            {
                Eol = 1,
            };
            
            for (int i = 0; i < len; i++)
            {
                if (p.CurrentState == State.Started)
                {

                    if (len < 8)
                    {
                        pm.Offset = 0;
                        p.MoveNext(Command.Offset);
                        continue;
                    }

                    int offset = 0;
                    if (_smlookup1[span[0]] != 0xff
                        && _smlookup2[span[0]] != 0xff
                        && _smlookup1[span[1]] != 0xff
                        && _smlookup2[span[1]] != 0xff
                        && _smlookup1[span[2]] != 0xff
                        && _smlookup2[span[2]] != 0xff
                        && _smlookup1[span[3]] != 0xff
                        && _smlookup2[span[3]] != 0xff
                        && span[4] == ' '
                        && span[5] == ' '
                        && span[6] == ' '
                        && span[7] == ' '
                    )
                    {
                        offset = 8;
                    }

                    pm.Offset = offset;
                    p.MoveNext(Command.Offset);
                    i += offset;
                    continue;
                }

                else if (p.CurrentState == State.Offset)
                {
                    if (i + 3 >= len)
                    {
                        pm.Hex = len - pm.Offset;
                        p.MoveNext(Command.Hex);
                        continue;
                    }
                    
                    if (span[i] == ' '
                        && span[i + 1] == ' '
                        && span[i + 2] == ' '
                        && span[i + 3] == ' ')
                    {
                        pm.Hex = i - pm.Offset;
                        p.MoveNext(Command.Hex);
                        continue;
                    }
                    
                    if (span[i + 3] == '\n'
                         || span[i + 3] == '\r'
                         )
                    {
                        pm.Hex = i - pm.Offset + 3;
                        p.MoveNext(Command.Hex);
                        continue;
                    }

                }

                else if (p.CurrentState == State.Hex)
                {
                    
                    if (
                        i + 1 == len
                    )
                    {
                        pm.Ascii = i - pm.Offset - pm.Hex + 1;
                        p.MoveNext(Command.Ascii);
                        continue;
                    }

                    
                    if (
                        i + 1 < len
                        && (
                            span[i + 1] == '\n'
                            || span[i + 1] == '\r')
                    )
                    {
                        pm.Ascii = i - pm.Offset - pm.Hex + 1;
                        p.MoveNext(Command.Ascii);
                        continue;
                    }
                    
                    if (
                        span[i] == '\n'
                        || span[i] == '\r'
                    )
                    {
                        pm.Ascii = i - pm.Offset - pm.Hex;
                        p.MoveNext(Command.Ascii);
                        continue;
                    }
                }
                
                else if (p.CurrentState == State.Ascii)
                {
                    if (span[i] == '\r')
                    {
                        pm.Eol = 2;
                        p.MoveNext(Command.NewLine);
                        continue;
                    }
                    if (span[i] == '\n')
                    {
                        pm.Eol = 1;
                        p.MoveNext(Command.NewLine);
                        continue;
                    }
                }

                else if (p.CurrentState == State.NewLine)
                {
                    break;
                }
                else
                {
                    break;
                }

            }

            return pm;
        }



        public enum State
        {
            Started,
            Offset,
            Hex,
            Ascii,
            NewLine,
            Analysed
        }

        public enum Command
        {
            Offset,
            Hex,
            Ascii,
            NewLine,
            Analysed
        }

        public class Process
        {
            class StateTransition
            {
                readonly State Current;
                readonly Command Command;

                public StateTransition(State current, Command command)
                {
                    Current = current;
                    Command = command;
                }

                public override int GetHashCode()
                {
                    return 17 + 31 * Current.GetHashCode() + 31 * Command.GetHashCode();
                }

                public override bool Equals(object obj)
                {
                    StateTransition other = obj as StateTransition;
                    return other != null && this.Current == other.Current
                                         && this.Command == other.Command;
                }
            }

            Dictionary<StateTransition, State> transitions;
            public State CurrentState { get; private set; }

            public Process()
            {
                CurrentState = State.Started;
                transitions = new Dictionary<StateTransition, State>
                {
                    {new StateTransition(State.Started, Command.Offset), State.Offset},
                    {new StateTransition(State.Offset, Command.Hex), State.Hex},
                    {new StateTransition(State.Hex, Command.Ascii), State.Ascii},
                    {new StateTransition(State.Ascii, Command.NewLine), State.NewLine},
                    {new StateTransition(State.Hex, Command.NewLine), State.NewLine},
                    {new StateTransition(State.NewLine, Command.Analysed), State.Analysed},
                    {new StateTransition(State.Hex, Command.Analysed), State.Analysed},
                };
            }

            public State GetNext(Command command)
            {
                StateTransition transition = new StateTransition(CurrentState, command);
                State nextState;
                if (!transitions.TryGetValue(transition, out nextState))
                    throw new Exception("Invalid transition: " + CurrentState + " -> " + command);
                return nextState;
            }

            public State MoveNext(Command command)
            {
                CurrentState = GetNext(command);
                return CurrentState;
            }

        }
    }
}
